#L/A = (1/I^2)[(s1-s2)*Q_dot1 + (s2-s3)*Q_dot2 + ... + (s_n-1-s_n)*Q_dotn-1+s_n*Q_dot_n]
#Q_dot = I[2*(k/s)_avg(TH-TL)]^.5

#use owens code to determine RMS of steady state ohmic heating power during run

#LI/A = [(s1-s2)*(2(k/s)_avg*(TH-TL))^0.5 + ...]

#s = cm/ohms (resistivity)
#K = thermal conductivity
#TH = high temp of step
#TL = low temp of step

#want to generate curve for each initial temp (increments of 5K?)
#%%
from numpy.lib.type_check import _asfarray_dispatcher
import heat_analysis
import pandas as pd
import Constants
from matplotlib import pyplot as plt
from scipy.optimize import curve_fit
import numpy as np
import materials_properties
from scipy.interpolate import interp1d

#%%

def calc_resistivity_2(TL, TH, material, S):

    '''
    Use input array of T to generate array of resistivity, given a material
    
    T = maximum temperature for range
    material = constant
    resistivity (sigma) = array, 1/ohm*m
    '''

    # Wiedemann - Franz - Lorenz : thermal conductivity = LN * T / resistivity
    LN = 2.23*10**-8# V^2 / K^2

    for t in range(TL, TH+5, 5): #right now in 5K increments
        sig = heat_analysis.thermal_conductivity_of(material, t)/(LN*t) #units: 1/ohm*m
        S.append(sig)

    #S = S[::-1] #invert so go hot to cold, as heat travels, 

def calc_resistivity(TL, TH, material, S):

    for t in range(TL, TH+5, 5): #right now in 5K increments
        #sig = 1/materials_properties.resistivity_of(material, t) #units: 1/ohm*m
        sig = 1/resistivity_of(material, t) #units: 1/ohm*m
        S.append(sig)


def generate_thermal_conductivity_array(TL, TH, material, K):

    '''
    Use input array of T to generate array of thermal conductivity, given a material

    T = maximum temperature for range
    material = constant
    thermal conductivity = array, units: W/(m*K)
    '''

    for t in range(TL, TH+5, 5): #right now in 5K increments, starting at 15K
        k = materials_properties.thermal_conductivity_of(material, t) #units: W/(m*K)
        K.append(k)
    #print(K)

    #K = K[::-1] #invert so go hot to cold, as heat travels

def generate_arrays(T_full_array, material):

    K_array = []
    S_array = []

    generate_thermal_conductivity_array(T_full_array[0], T_full_array[-1], material, K_array)
    calc_resistivity(T_full_array[0], T_full_array[-1], material, S_array)

    return K_array, S_array

def generate_dataframe(T_full_array, K_array, S_array, df):

    df['Temp_Index'] = T_full_array
    df['Thermal Conductivity (W/K*m)'] = K_array
    df['Electrical Conductivity (1/ohm*m)'] = S_array


def calc_LIA_Const(TH, TL, n, df):

    '''
    df is a pandas dataframe generated by the function generate dataframe with columns for temperature step, K, S
    TH is integer, high temperature (T0)
    TL is integer, low temperature (Tf)
    n is integer (number of temperature steps) 

    LIA is a float
    '''
    
    j = 1
    LIA = 0

    for i in range(TH, TL+n, -n):

        kos_sum = 0

        for k in range(TH, TH-n*j, -n):

            row = df.loc[df["Temp_Index"]==k]
            kos_sum = row.iat[0,1]/row.iat[0,2] + kos_sum

        kos_avg = (1/j) * kos_sum

        #print("kos avg is " + str(kos_avg))

        row0 = df.loc[df["Temp_Index"]==i]
        #print("row 0 is " + str(row0))
        row1 = df.loc[df["Temp_Index"]==i-n]
        #print("row 1 is " + str(row1))

        LIA = (row1.iat[0,2]-row0.iat[0,2])*(2*kos_avg*(TH-TL))**0.5 + LIA 
        j = j + 1

    #LIA = LIA/100 #convert to cm to check against mcfee
    return LIA #unit: A/m

def LIA_sweep(df, TH, TL, n):

    '''
    df is pandas dataframe, generated by the function generate_dataframe
    TH is integer, high temperature (T0)
    TL is integer, low temperature (Tf)
    n is integer (number of temperature steps) 

    LIA is a float
    '''

    T_full_array = list(range(TH-n, TL-n, -n))

    LIA_array = []

    for i in range(TH-n, TL-n, -n):
        #print(i)
        LIA_temp = calc_LIA_Const(TH, i, n, df)
        LIA_array.append(LIA_temp)

    T_sweep = list(range(TH, TL, -n))

    return LIA_array, T_sweep

def determine_CSA(TH, TL, n_L_step, n_LIA, fit_func, system_temp_array, system_position_array, I, df):

    '''
    TH is T0 (int)
    TL is Tf (int)
    n_L_step is temperature step on system (int)
    n_LIA is discrete steps for calculate LIA constant (int)
    fit_func is which fit best describes your system's temperature vs length profile (function)
    system_temp_array is temperature measurements from your system (list)
    system_position_array is corresponding position measurements (list)
    I is current (int or float)
    df is pandas dataframe holding K, S, T values created by function generate_dataframe
    '''

    temp_step_array = list(range(TH, TL, -n_L_step))
    popt, pcov = curve_fit(fit_func, system_temp_array, system_position_array)
    LIA_array = []
    CSA_array = []
    L_array = []
    L0 = 0

    for T in temp_step_array:
        #print ("T is " + str(T))
        LIA_calc = calc_LIA_Const(T, T-n_L_step, n_LIA, df)
        LIA_array.append(LIA_calc)
        l_0 = fit_func(T, *popt)
        l_1 = fit_func(T-n_L_step, *popt)
        L = l_0 - l_1
        L0 = L0 + L
        A = L*I/LIA_calc
        A = A * 1e6 #convert to mm2
        CSA_array.append(A)
        L_array.append(L0)

    plt.scatter(L_array, CSA_array)
    
    return LIA_array, CSA_array, L_array

def generate_discrete_csa_vs_length(length_array, csa_array, fit_func, length):

    popt_csa_fit, pcov = curve_fit(fit_func, length_array, csa_array)
    
    length_range = list(range(length)) #mm
    length_range_m = [x/1000 for i,x in enumerate(length_range)] #m

    pow = []
    for elem in length_range_m:
        pow0 = fit_func(elem, *popt_csa_fit)
        pow.append(pow0)

    plt.scatter(length_range_m, pow)
    
    return length_array, pow

def exp_func(x, a, b, c):
    return a * np.exp(b*x) + c
def lin_func(x, m, b):
    return m*np.array(x) + b
def power_func(x, a, b, c):
    return a * x**b + c

#%%

T_full_array = list(range(15, 300, 5)) #T_min = 15, T_max = 290, T_step = 5

K = []
S = []
LIA = []
T = []

K, S = generate_arrays(T_full_array, Constants.MATERIAL.CU_R3_100.value)

df_vals = pd.DataFrame()
generate_dataframe(T_full_array, K, S, df_vals)

#%%

LIA, T = LIA_sweep(df_vals, 290, 70, 5)
plt.plot(T, LIA)
plt.xlabel("Temperature (K)")
plt.ylabel("LIA")
plt.show()

#%%

I_rms = 650 * 121/590 #from Owen

sampleWand_temp_array = [276, 103, 28, 20]
sampleWand_position_array = [.820, .430, .215, .070]
x_data = list(range(70,820))

#popt_exp, pcov_exp = curve_fit(exp_func, sampleWand_position_array, sampleWand_temp_array)
popt_lin, pcov_lin = curve_fit(lin_func, sampleWand_position_array, sampleWand_temp_array)
popt_power, pcov_power = curve_fit(power_func, sampleWand_position_array, sampleWand_temp_array)
popt_power_inv, pcov_power_inv = curve_fit(power_func, sampleWand_temp_array, sampleWand_position_array)

#%%
plt.scatter(sampleWand_position_array, sampleWand_temp_array)
plt.plot(x_data, lin_func(x_data, *popt_lin))
plt.show()

plt.scatter(sampleWand_position_array, sampleWand_temp_array)
plt.plot(x_data, power_func(x_data, *popt_power))
plt.show()

x_inv_data = list(range(20, 276))
plt.scatter(sampleWand_temp_array, sampleWand_position_array)
plt.plot(x_inv_data, power_func(x_inv_data, *popt_power_inv))
plt.show()

#%%
test = determine_CSA(295, 15, 20, 5, power_func, sampleWand_temp_array, sampleWand_position_array, I_rms, df_vals)
print(test[1])  



# %%

#K = pd.DataFrame()
#S = pd.DataFrame()
#T = pd.DataFrame()

#K, S, T = generate_arrays(T_full_array, Constants.MATERIAL.CU_R3_100.value)
#print(K)

#LIA = pd.DataFrame()

def calc_LIA_Const_deprecated(K, S, TH, TL):

    LIA_full = pd.DataFrame()
    j = 0

    for i in range(len(T_full_array)-1):

        name = str(T_full_array[i])
        LIA_temp = pd.DataFrame()
        
        for k in range(i, j):
            LIA_j = (S[i+1]-S[i])*((2*((K[i] + K[i+1])/(S[i] + S[i+1]))/2)*(T[j]-T[i]))**0.5
            

        j = j + 1

        1


    return 1

def generate_arrays_deprecated(T_full_array, material):
    
    K_full = pd.DataFrame()
    S_full = pd.DataFrame()
    T_full = pd.DataFrame()

    for i in range(len(T_full_array)):
        
        original = pd.DataFrame()
        name = str(T_full_array[i])

        name_K = "K_" + name
        k_array = [] 
        generate_thermal_conductivity_array(T_full_array[i], material, k_array)
        df_K = pd.DataFrame()
        df_K[name_K] = k_array
        original = K_full
        K_full = pd.concat([original,df_K], axis=1)

        name_S = "S_" + name
        s_array = []
        calc_resistivity(T_full_array[i], material, s_array)
        df_S = pd.DataFrame()
        df_S[name_S] = s_array
        original = S_full
        S_full = pd.concat([original, df_S], axis=1)
        
        name_T = "T_" + name
        T_array = list(range(15, T_full_array[i], 5))
        df_T = pd.DataFrame()
        df_T[name_T] = T_array
        original = T_full
        T_full = pd.concat([original, df_T],axis=1)
        
    #print(K_full)
    return K_full, S_full, T_full
    #print(K)

def calc_LIA_Const_deprecated(K, S, TH, TL, n):

    '''
    K is list, thermal conductivity
    S is list, electrical conductivity
    TH is integer, high temperature (T0)
    TL is integer, low temperature (Tf)
    n is integer (number of temperature steps) 

    LIA is a float
    '''

    T_full_array = list(range(TL-n, TH+n, n))
    #print(T_full_array)

    T_full_array_inverted = T_full_array[::-1] #invert so go hot to cold, as heat travels

    index_low = T_full_array_inverted.index(TL)
    index_high = T_full_array_inverted.index(TH)

    j = 1
    LIA = 0

    for i in range(index_high, index_low):

        kos_sum = 0

        for k in range(index_high, j+index_high):
            
            kos_sum = K[k]/S[k] + kos_sum 
            #print(kos_sum)

        kos_avg = (1/j) * kos_sum
        LIA = (S[i]-S[i+1])*(2*kos_avg*(TH-TL))**0.5 + LIA #S[i] not same i!
        j = j + 1

    return LIA #unit: A/m

def LIA_sweep_deprecated(K, S, TH, TL, n):

    '''
    K is list, thermal conductivity
    S is list, electrical conductivity
    TH is integer, high temperature (T0)
    TL is integer, low temperature (Tf)
    n is integer (number of temperature steps) 

    LIA is a float
    '''

    LIA_array = []

    T_full_array = list(range(TL-n, TH+n, n))
    T_full_array_inverted = T_full_array[::-1]
    index_low = T_full_array_inverted.index(TL)
    #print(index_low)
    index_high = T_full_array_inverted.index(TH)
    #print(index_high)

    for i in range(index_high+1, index_low+1):
        LIA_temp = calc_LIA_Const(K, S, TH, T_full_array_inverted[i], n)
        LIA_array.append(LIA_temp)
        #print(T_full_array_inverted[i])
        #print(LIA_temp)

    T_sweep = list(range(TL, TH, 5))
    T_sweep_inverted = T_sweep[::-1]

    #print(LIA_array)

    return LIA_array, T_sweep_inverted

#%%
def resistivity_of(material,T):
    """ returns the resistivity of a material at a given temperature  
    Args:
        material: [string] must be a case in Resistivity_of
        T: [float] temperature [K]
    Returns:
        rho: [float] resistivity Ohm*m

    Data from Appendix 6.5a,b in Ekin p.575-576, in Ohm*m*10^-8    
    Wiedemann - Franz - Lorenz : thermal conductivity = LN * T / resistivity
    """
    LN = 2.44*10**-8# V^2 / K^2
    # LN 2.23 # copper
    # rho=LN*T/thermal_conductivity_of(material,T)

    #print("Aliya")

    T_points = [10,20,50,77,100,150,200,250,295]
    if material ==Constants.MATERIAL.CU_R3_100.value: 
        R_points =  [0.015,0.017,0.084,0.21,0.34,0.70,1.07,1.41,1.70]
        func = interp1d(T_points,R_points,kind='linear',bounds_error=None)
        rho = func(T)*1e-8
    elif material ==Constants.MATERIAL.SS_316.value:
        R_points = [53.9,53.9,54.9,56.8,58.8,63.8,68.9,73.3,77.1]
        func = interp1d(T_points,R_points,kind='linear',bounds_error=None)
    elif material == Constants.MATERIAL.HTS.value: 
        # source: "Optimization Method for Extracting Stabilizer Geometry and Properties of REBCO Tapes" Riva 2021
        if T<80:
            rho = 0
        else:
            rho= 0.3957*Constants.uOHM_CM_TO_OHM_M
    else: 
        R_points = 1e20 * np.ones_like(T_points)
        func = interp1d(T_points,R_points,kind='linear',bounds_error=None)
   

    return rho
# %%
